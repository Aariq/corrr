---
title: "corrr"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

corrr is a package for exploring **corr**elation matrices in **R**. It makes it possible to easily perform routine tasks when exploring correlation matrices such as comparing only some variables against others, or arranging the matrix in terms of the strength of the correlations, and so on. `corrr` also provides visualisation methods for extracting useful information such as variable clustering and latent dimensionality.

`corrr` is intended to be used for exploration and visualisation, NOT for statistical modeling (obtaining p values, factor analysis, etc.).

You can install:

- the latest development version from github with

```{r install_git, eval = FALSE}
if (packageVersion("devtools") < 1.6) {
  install.packages("devtools")
}
devtools::install_github("drsimonj/corrr")
```

## Getting Started

`corrr` centers around the `correlate()` function, which returns a correlation matrix generated by `stats::cor()`, but in a  format of the following:

- A tibble::data_frame
- An additional class, "cor_df"
- A "rowname" column
- Standardised variances (the matrix diagonal) set to missing values (`NA`) so they can be ignored in calculations.

Another small adjustment is that `correlate()` uses pairwise deletion by default.

```{r}
library(MASS)
library(corrr)
set.seed(1)

# Simulate three columns correlating about .7 with each other
mu <- rep(0, 3)
Sigma <- matrix(.7, nrow = 3, ncol = 3) + diag(3)*.3
seven <- mvrnorm(n = 1000, mu = mu, Sigma = Sigma)

# Simulate three columns correlating about .4 with each other
mu <- rep(0, 3)
Sigma <- matrix(.4, nrow = 3, ncol = 3) + diag(3)*.6
four <- mvrnorm(n = 1000, mu = mu, Sigma = Sigma)

# Bind together
d <- cbind(seven, four)
colnames(d) <- paste0("v", 1:ncol(d))

# Insert some missing values
d[sample(1:nrow(d), 100, replace = TRUE), 1] <- NA
d[sample(1:nrow(d), 200, replace = TRUE), 5] <- NA

# Correlate
x <- correlate(d)
class(x)
x
```

## corrr and dplyr

By using the data_frame structure, we can leverage functions from packages like `dplyr`. Below are some useful examples:

```{r, message = FALSE, warning = FALSE}
library(dplyr)

# Select a subset of variables by column
x %>% select(rowname, v1, v2)

# Select a subset of variables by rows (using filter)
x %>% filter(rowname %in% c("v1", "v2"))

# Select columns and rows
x %>%
  filter(rowname %in% paste0("v", 4:6)) %>%
  select(rowname, v1:v3)

# Filter rows by correlation size
x %>% filter(v1 > .6)

# Calculate the mean correlation for each variable
x %>%
  select(-rowname) %>%
  summarise_each(funs(mean(., na.rm = TRUE))) %>%
  round(2)

```

## Routine Explorations

`corrr` provides convenience functions for routine explorations of the matrix.


### xselect()

xselect() behaves similarly to dplyr::select(), but excludes whichever columns you select from the rows. It takes your correlate() correlation matrix, and then expressions you would use in select(). Here are some examples of using xselect():

```{r}
# select v1 and v2 to stay in the columns
x %>% xselect(v1, v2)

# Or put these variables into the rows by dropping from columns
x %>% xselect(-v1, -v2)

# And can use any dplyr::select() expressions
x %>% xselect(num_range("v", 1:3))
```

